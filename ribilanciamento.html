<!DOCTYPE html>
<html lang="it">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ribilanciamento Asset con simulazione montecarlo</title>
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
    <link href="css/style.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.5.4/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.0.2"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }

        h2 {
            margin-top: 30px;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            max-width: 900px;
        }

        label {
            font-size: 14px;
        }

        input,
        select {
            width: 100%;
        }

        button {
            padding: 10px;
            margin-top: 15px;
            font-size: 16px;
        }

        canvas {
            margin-top: 30px;
        }

        .results {
            margin-top: 30px;
            font-size: 14px;
        }
    </style>
</head>

<body class="bg-light">
    <div class="container mt-5 p-4 bg-white rounded shadow-sm">
        <div class="text-center mb-4">
            <a href="/FireSWR" class="home-button">üè† Home</a>
        </div>
        <br>
        <h1 class="text-center">Ribilanciamento Asset con simulazione montecarlo</h1>
        <h5 class="text-center">Mostra l'effetto del ribilanciamento su un portafoglio ipotetico composto da 2 asset con
            diversi rendimenti e volatilit√†. A fondo pagina una simulazione Monte Carlo che mostra i risultati medi.
        </h5>


        <div class="controls">
            <label>Rendimento Asset A (%)<input id="retA" type="number" value="7"></label>
            <label>Volatilit√† Asset A (%)<input id="volA" type="number" value="15"></label>
            <label>Peso Asset A (%)<input id="wA" type="number" value="60"></label>
            <label>Aliquota Asset A (%)<input id="taxA" type="number" value="26"></label>

            <label>Rendimento Asset B (%)<input id="retB" type="number" value="3"></label>
            <label>Volatilit√† Asset B (%)<input id="volB" type="number" value="5"></label>
            <label>Peso Asset B (%)<input id="wB" type="number" value="40"></label>
            <label>Aliquota Asset B (%)<input id="taxB" type="number" value="12.5"></label>


            <label>Correlazione Asset A e B<input id="corrAB" type="number" value="-0.05" step="0.01" min="-1"
                    max="1"></label>
            <label>Anni simulazione<input id="years" type="number" value="20"></label>
            <label>Ribilanciamento
                <select id="rebalance">
                    <option value="1">Annuale</option>
                    <option value="2">Biennale</option>
                </select>
            </label>
            <label>Costo ribilanciamento (‚Ç¨)<input id="cost" type="number" value="20"></label>

            <label><input type="checkbox" id="enableTax" checked>Applica tassazione alla vendita</label>
            <label><input type="checkbox" id="enableMinusComp" checked>Compensa minusvalenze</label>
            <label>Simulazioni Monte Carlo<input id="sims" type="number" value="300"></label>

        </div>

        <button onclick="run()">Avvia simulazione</button>
        <h2 class="mb-3">Singola simulazione</h2>
        <canvas id="chart" height="120"></canvas>
        <div class="results" id="statsSingle"></div>
        <h2 class="mb-3">üìä Simulazione Monte Carlo</h2>
        <canvas id="chartMonteCarlo" height="120"></canvas>
        <div class="results" id="stats"></div>
        <div class="card mt-4">
            <div class="card-body">
                <h5 class="card-title">Riepilogo statistico Monte Carlo</h5>
                <ul>
                    <li>
                        % simulazioni dove <strong>Ribilanciamento</strong> batte <strong>Buy & Hold</strong> (lordo):
                        <strong id="statLordo"></strong>
                    </li>
                    <li>
                        % simulazioni dove <strong>Ribilanciamento</strong> batte <strong>Buy & Hold</strong> (netto):
                        <strong id="statNetto"></strong>
                    </li>
                    <li>
                        % simulazioni dove <strong>Ribilanciamento</strong> ha <strong>volatilit√† inferiore</strong>:
                        <strong id="statVol"></strong>
                    </li>
                    <li>
                        Quando il <strong>Netto ribilanciato</strong> batte il <strong>Buy & Hold</strong>,
                        lo fa in media del: <strong id="statExtraNetto"></strong> del guadagno
                    </li>
                </ul>
            </div>
        </div>
        <script>
            function mostraRiepilogoStatistiche(simulazioni) {
                const stats = calcolaStatisticheMonteCarlo(simulazioni);
                document.getElementById("statLordo").innerText = stats.lordoRebVincePerc + "%";
                document.getElementById("statNetto").innerText = stats.nettoRebVincePerc + "%";
                document.getElementById("statVol").innerText = stats.volRebMinorePerc + "%";
                document.getElementById("statExtraNetto").innerText = stats.extraNettoMedioPerc + "%";
            }
            /* =======================
               GENERA DUE ASSET CORRELATI
            ======================= */
            function generateCorrelatedPaths(years, retA, volA, retB, volB, corr) {
                let pathA = [1];
                let pathB = [1];

                // Matrice di covarianza
                const cov = [
                    [volA * volA, corr * volA * volB],
                    [corr * volA * volB, volB * volB]
                ];

                // Cholesky decomposition (2x2)
                const L = [
                    [Math.sqrt(cov[0][0]), 0],
                    [cov[1][0] / Math.sqrt(cov[0][0]), Math.sqrt(cov[1][1] - (cov[1][0] ** 2) / cov[0][0])]
                ];

                for (let i = 1; i <= years; i++) {
                    // Genera due normali indipendenti
                    const z1 = randn();
                    const z2 = randn();

                    // Combina usando Cholesky per correlazione
                    const rA = retA + (L[0][0] * z1 + L[0][1] * z2);
                    const rB = retB + (L[1][0] * z1 + L[1][1] * z2);

                    pathA.push(pathA[i - 1] * (1 + rA));
                    pathB.push(pathB[i - 1] * (1 + rB));
                }

                return { pathA, pathB };
            }
            /* =======================
               Wrapper per compatibilit√†
            ======================= */
            function generatePaths(years, retA, volA, retB, volB) {
                const corr = +document.getElementById("corrAB").value;
                return generateCorrelatedPaths(years, retA, volA, retB, volB, corr);
            }


            /* =======================
               COSTANTI
            ======================= */
            const START_CAPITAL = 100000;
            const TAX = 0.26;
            let chart = null;
            let chartMC = null;

            function returnsFromEquity(equity) {
                let r = [];
                for (let i = 1; i < equity.length; i++) {
                    r.push(equity[i] / equity[i - 1] - 1);
                }
                return r;
            }

            function mean(arr) {
                return arr.reduce((s, x) => s + x, 0) / arr.length;
            }

            function stdDev(arr) {
                let m = mean(arr);
                return Math.sqrt(arr.reduce((s, x) => s + (x - m) ** 2, 0) / arr.length);
            }
            /* =======================
               RANDOM NORMALE
            ======================= */
            function randn() {
                let u = 0, v = 0;
                while (u === 0) u = Math.random();
                while (v === 0) v = Math.random();
                return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
            }

            /* =======================
               SIMULAZIONE ASSET
            ======================= */
            function simulateAsset(ret, vol, years) {
                let path = [1];
                for (let i = 1; i <= years; i++) {
                    let r = ret + vol * randn();
                    path.push(path[i - 1] * (1 + r));
                }
                return path;
            }

            /* =======================
               GENERA PATH COMUNI
            ======================= */
            function generatePaths(years, retA, volA, retB, volB) {
                const corr = +document.getElementById("corrAB").value;
                return generateCorrelatedPaths(years, retA, volA, retB, volB, corr);
            }

            /* =======================
               BUY & HOLD
            ======================= */
            function portfolioNoRebalance(pathA, pathB, wA, wB) {
                let unitsA = (START_CAPITAL * wA) / pathA[0];
                let unitsB = (START_CAPITAL * wB) / pathB[0];

                let costBasisA = START_CAPITAL * wA;
                let costBasisB = START_CAPITAL * wB;

                const taxEnabled = document.getElementById("enableTax").checked;
                const taxA = +document.getElementById("taxA").value / 100;
                const taxB = +document.getElementById("taxB").value / 100;

                let equityGross = [START_CAPITAL];
                let equityNet = [START_CAPITAL];

                let taxesLatent = 0;

                for (let i = 1; i < pathA.length; i++) {
                    const valueA = unitsA * pathA[i];
                    const valueB = unitsB * pathB[i];
                    const totalGross = valueA + valueB;

                    let netA = valueA;
                    let netB = valueB;

                    if (taxEnabled) {
                        const gainA = Math.max(0, valueA - costBasisA);
                        const gainB = Math.max(0, valueB - costBasisB);

                        taxesLatent = gainA * taxA + gainB * taxB;

                        netA -= gainA * taxA;
                        netB -= gainB * taxB;
                    }

                    equityGross.push(totalGross);
                    equityNet.push(netA + netB);
                }

                return {
                    equityGross,
                    equityNet,
                    taxesLatent
                };
            }


            /* =======================
            PORTAFOGLIO CON RIBILANCIAMENTO CORRETTO
            ======================= */
            function portfolioWithRebalance(pathA, pathB, wA, wB, freq, cost) {
                let unitsA = (START_CAPITAL * wA) / pathA[0];
                let unitsB = (START_CAPITAL * wB) / pathB[0];

                let costBasisA = START_CAPITAL * wA; // quanto hai speso realmente
                let costBasisB = START_CAPITAL * wB;

                const taxEnabled = document.getElementById("enableTax").checked;
                const minusEnabled = document.getElementById("enableMinusComp")?.checked ?? true;
                const taxRateA = +document.getElementById("taxA").value / 100;
                const taxRateB = +document.getElementById("taxB").value / 100;

                let minusCarry = 0;   // minusvalenze accumulate
                let taxesPaid = 0;

                let equityGross = [START_CAPITAL];
                let equityNet = [START_CAPITAL];

                // ================= UTIL =================
                function compensateGain(gain, taxRate) {
                    if (!taxEnabled || gain <= 0) {
                        if (gain < 0 && minusEnabled) minusCarry += Math.abs(gain);
                        return Math.max(0, gain);
                    }
                    if (!minusEnabled) return gain;

                    const gainEq26 = gain * (taxRate / 0.26);
                    const usedMinus = Math.min(gainEq26, minusCarry);
                    minusCarry -= usedMinus;
                    return gain - usedMinus * (0.26 / taxRate);
                }

                for (let i = 1; i < pathA.length; i++) {
                    let valueA = unitsA * pathA[i];
                    let valueB = unitsB * pathB[i];
                    let total = valueA + valueB;

                    // ================= RIBILANCIAMENTO =================
                    if (freq > 0 && i % freq === 0) {
                        const targetA = total * wA;
                        const targetB = total * wB;

                        // ===== VENDITE E TASSE =====
                        let cashFromSales = 0;

                        // Asset A sopra target
                        if (valueA > targetA) {
                            const sellA = valueA - targetA;
                            const basisSoldA = costBasisA * (sellA / valueA);
                            let gainA = sellA - basisSoldA;

                            gainA = compensateGain(gainA, taxRateA);
                            const taxA = gainA * taxRateA;

                            taxesPaid += taxA;
                            cashFromSales += sellA - taxA;

                            unitsA -= sellA / pathA[i];
                            costBasisA -= basisSoldA;
                        }

                        // Asset B sopra target
                        if (valueB > targetB) {
                            const sellB = valueB - targetB;
                            const basisSoldB = costBasisB * (sellB / valueB);
                            let gainB = sellB - basisSoldB;

                            gainB = compensateGain(gainB, taxRateB);
                            const taxB = gainB * taxRateB;

                            taxesPaid += taxB;
                            cashFromSales += sellB - taxB;

                            unitsB -= sellB / pathB[i];
                            costBasisB -= basisSoldB;
                        }

                        // ===== COSTO RIBILANCIAMENTO =====
                        cashFromSales -= cost;

                        // ===== COMPRA ASSET SOTTO TARGET =====
                        const deficitA = targetA - unitsA * pathA[i];
                        const deficitB = targetB - unitsB * pathB[i];

                        const totalDeficit = deficitA + deficitB;

                        if (totalDeficit > 0 && cashFromSales > 0) {
                            const buyA = (deficitA / totalDeficit) * cashFromSales;
                            const buyB = (deficitB / totalDeficit) * cashFromSales;

                            unitsA += buyA / pathA[i];
                            costBasisA += buyA;

                            unitsB += buyB / pathB[i];
                            costBasisB += buyB;
                        }

                        total = unitsA * pathA[i] + unitsB * pathB[i];
                    }

                    // ================= EQUITY =================
                    const gross = unitsA * pathA[i] + unitsB * pathB[i];
                    equityGross.push(gross);

                    // ================= NETTO =================
                    let net = gross;
                    if (taxEnabled) {
                        // calcolo capital gain finale
                        let finalGainA = Math.max(0, unitsA * pathA[i] - costBasisA);
                        let finalGainB = Math.max(0, unitsB * pathB[i] - costBasisB);

                        finalGainA = compensateGain(finalGainA, taxRateA);
                        finalGainB = compensateGain(finalGainB, taxRateB);

                        net -= finalGainA * taxRateA;
                        net -= finalGainB * taxRateB;
                    }
                    equityNet.push(net);
                }

                // Capital gain finale (tasse se liquidassi oggi)
                const finalCapitalGainTax = taxEnabled
                    ? (Math.max(0, unitsA * pathA.at(-1) - costBasisA) * taxRateA
                        + Math.max(0, unitsB * pathB.at(-1) - costBasisB) * taxRateB)
                    : 0;


                return {
                    equityGross,
                    equityNet,
                    taxesPaid,
                    minusCarry,
                    finalCapitalGainTax
                };
            }


            /* =======================
               CALCOLO STATISTICHE MONTE CARLO
            ======================= */
            function calcolaStatisticheMonteCarlo(simulazioni) {
                let countLordoRebVince = 0;
                let countNettoRebVince = 0;
                let countVolRebMinore = 0;
                let extraNettoPercSum = 0;
                let extraNettoPercCount = 0;

                simulazioni.forEach(sim => {

                    // Rebalance batte Buy&Hold
                    if (sim.lordoRebalance > sim.lordoNoRebalance) {
                        countLordoRebVince++;
                    }

                    if (sim.nettoRebalance > sim.nettoNoRebalance) {
                        countNettoRebVince++;

                        const gainNo = sim.nettoNoRebalance - START_CAPITAL;
                        const extra = sim.nettoRebalance - sim.nettoNoRebalance;

                        // calcola extra % solo se ha senso
                        if (gainNo > 0) {
                            extraNettoPercSum += extra / gainNo;
                            extraNettoPercCount++;
                        }
                    }

                    // Rebalance RIDUCE la volatilit√†
                    if (sim.volRebalance < sim.volNoRebalance) {
                        countVolRebMinore++;
                    }
                });

                const totale = simulazioni.length;

                return {
                    lordoRebVincePerc: (countLordoRebVince / totale * 100).toFixed(1),
                    nettoRebVincePerc: (countNettoRebVince / totale * 100).toFixed(1),
                    volRebMinorePerc: (countVolRebMinore / totale * 100).toFixed(1),
                    extraNettoMedioPerc: extraNettoPercCount > 0 ? (extraNettoPercSum / extraNettoPercCount * 100).toFixed(2) : "0.00"
                };
            }

            /* =======================
               RUN
            ======================= */
            function run() {
                const years = +document.getElementById("years").value;
                const retA = +document.getElementById("retA").value / 100;
                const volA = +document.getElementById("volA").value / 100;
                const retB = +document.getElementById("retB").value / 100;
                const volB = +document.getElementById("volB").value / 100;
                const wA = +document.getElementById("wA").value / 100;
                const wB = +document.getElementById("wB").value / 100;
                const cost = +document.getElementById("cost").value;

                const { pathA, pathB } = generatePaths(years, retA, volA, retB, volB);

                const eqNo = portfolioNoRebalance(pathA, pathB, wA, wB);
                const eqRe = portfolioWithRebalance(pathA, pathB, wA, wB, 1, cost);

                // Asset valorizzati a 100k per confronto visivo
                const assetA = pathA.map(v => v * START_CAPITAL);
                const assetB = pathB.map(v => v * START_CAPITAL);

                const labels = pathA.map((_, i) => i);

                if (chart instanceof Chart) chart.destroy();

                chart = new Chart(document.getElementById("chart"), {
                    type: "line",
                    data: {
                        labels,
                        datasets: [
                            { label: "Asset A", data: assetA, borderWidth: 1, borderDash: [6, 6] },
                            { label: "Asset B", data: assetB, borderWidth: 1, borderDash: [6, 6] },
                            { label: "Buy & Hold", data: eqNo.equityGross, borderWidth: 2 },
                            { label: "Ribilanciamento annuale", data: eqRe.equityGross, borderWidth: 2 }
                        ]
                    }
                });

                // ===== Mostra riepilogo simulazione singola =====
                const volNoSingle = stdDev(returnsFromEquity(eqNo.equityGross));
                const volReSingle = stdDev(returnsFromEquity(eqRe.equityGross));

                const diffNet = eqRe.equityNet.at(-1) - eqNo.equityNet.at(-1);
                const gainNo = eqNo.equityNet.at(-1) - START_CAPITAL;

                const diffNetPerc = gainNo > 0 ? (diffNet / gainNo * 100).toFixed(2) : "n/a";

                document.getElementById("statsSingle").innerHTML = `
        <div class="mt-4">
            <h2 class="mb-3">üìä Risultati simulazione singola</h2>
            <p>Capitale iniziale: <b>100.000 ‚Ç¨</b></p>
            <div style="display:flex; gap:20px; flex-wrap:wrap;">

                <!-- BUY & HOLD -->
                <div style="flex:1; min-width:260px; padding:15px; border:1px solid #ddd; border-radius:8px;">
                    <h4>üìà Buy & Hold</h4>
                    <hr>
                    <div><b>Valore finale lordo:</b><br>${eqNo.equityGross.at(-1).toLocaleString()} ‚Ç¨</div>
                    <div><b>Tasse latenti finali:</b><br>${eqNo.taxesLatent.toLocaleString()} ‚Ç¨</div>
                    <div><b>Valore finale netto:</b><br>${eqNo.equityNet.at(-1).toLocaleString()} ‚Ç¨</div>
                    <div><b>Volatilit√† annua:</b><br>${(volNoSingle * 100).toFixed(2)} %</div>
                </div>

                <!-- RIBILANCIAMENTO -->
                <div style="flex:1; min-width:260px; padding:15px; border:1px solid #ddd; border-radius:8px;">
                    <h4>‚öñÔ∏è Ribilanciamento annuale</h4>
                    <hr>
                    <div><b>Valore finale lordo:</b><br>${eqRe.equityGross.at(-1).toLocaleString()} ‚Ç¨</div>
                    <div><b>Tasse pagate nel tempo:</b><br>${eqRe.taxesPaid.toLocaleString()} ‚Ç¨</div>
                    <div><b>Tasse capital gain finale:</b><br>${eqRe.finalCapitalGainTax.toLocaleString()} ‚Ç¨</div>
                    <div><b>Tasse totali:</b><br>${(eqRe.taxesPaid + eqRe.finalCapitalGainTax).toLocaleString()} ‚Ç¨</div>
                    <div><b>Valore finale netto:</b><br>${eqRe.equityNet.at(-1).toLocaleString()} ‚Ç¨</div>
                    <div><b>Volatilit√† annua:</b><br>${(volReSingle * 100).toFixed(2)} %</div>
                </div>               
            </div>
             <br>
                <div>
                    <div style="flex:1; min-width:260px; padding:15px; border:1px solid #ddd; border-radius:8px;">
                        <h4>üßÆ Differenze (Ribilanciato - Hold)</h4>
                        <hr>
                        <div><b>Differenza lordi:</b><br>${(eqRe.equityGross.at(-1) - eqNo.equityGross.at(-1)).toLocaleString()} ‚Ç¨</div>
                        <div><b>Differenza netti:</b><br>${(eqRe.equityNet.at(-1) - eqNo.equityNet.at(-1)).toLocaleString()} ‚Ç¨ (${diffNetPerc}% del guadagno)</div>
                        <div><b>Differenza volatilit√†:</b><br>${(volReSingle * 100 - volNoSingle * 100).toFixed(2)} %</div>
                    </div>
                </div>
        </div>
    `;

                // Esegui Monte Carlo
                monteCarlo();
            }

            /* =======================
               MONTE CARLO CON LORDO E NETTO
            ======================= */
            function monteCarlo() {
                const sims = +document.getElementById("sims").value;

                const years = +document.getElementById("years").value;
                const retA = +document.getElementById("retA").value / 100;
                const volA = +document.getElementById("volA").value / 100;
                const retB = +document.getElementById("retB").value / 100;
                const volB = +document.getElementById("volB").value / 100;
                const wA = +document.getElementById("wA").value / 100;
                const wB = +document.getElementById("wB").value / 100;
                const cost = +document.getElementById("cost").value;

                // Array per accumulare i valori per anno
                let eqNoGrossSum = Array(years + 1).fill(0);
                let eqNoNetSum = Array(years + 1).fill(0);
                let eqReGrossSum = Array(years + 1).fill(0);
                let eqReNetSum = Array(years + 1).fill(0);
                let assetASum = Array(years + 1).fill(0);
                let assetBSum = Array(years + 1).fill(0);
                let finalNoGross = [], finalNoNet = [];
                let finalReGross = [], finalReNet = [];
                let volNo = [], volRe = [];
                let simulazioni = [];
                let taxesNoSum = 0;
                let taxesReSum = 0;
                let finalCapitalGainReSum = 0;


                for (let i = 0; i < sims; i++) {
                    const { pathA, pathB } = generatePaths(years, retA, volA, retB, volB);

                    const eqNo = portfolioNoRebalance(pathA, pathB, wA, wB);
                    const eqRe = portfolioWithRebalance(pathA, pathB, wA, wB, 1, cost);

                    finalNoGross.push(eqNo.equityGross.at(-1));
                    finalNoNet.push(eqNo.equityNet.at(-1));

                    finalReGross.push(eqRe.equityGross.at(-1));
                    finalReNet.push(eqRe.equityNet.at(-1));
                    volNo.push(stdDev(returnsFromEquity(eqNo.equityGross)));
                    volRe.push(stdDev(returnsFromEquity(eqRe.equityGross)));
                    taxesNoSum += eqNo.taxesLatent;
                    taxesReSum += eqRe.taxesPaid;
                    finalCapitalGainReSum += eqRe.finalCapitalGainTax;



                    simulazioni.push({
                        lordoNoRebalance: eqNo.equityGross.at(-1),
                        lordoRebalance: eqRe.equityGross.at(-1),
                        nettoNoRebalance: eqNo.equityNet.at(-1),
                        nettoRebalance: eqRe.equityNet.at(-1),
                        volNoRebalance: stdDev(returnsFromEquity(eqNo.equityGross)),
                        volRebalance: stdDev(returnsFromEquity(eqRe.equityGross))
                    });


                    // somma valori per media
                    for (let t = 0; t <= years; t++) {
                        eqNoGrossSum[t] += eqNo.equityGross[t];
                        eqNoNetSum[t] += eqNo.equityNet[t];
                        eqReGrossSum[t] += eqRe.equityGross[t];
                        eqReNetSum[t] += eqRe.equityNet[t];
                        assetASum[t] += pathA[t] * START_CAPITAL;
                        assetBSum[t] += pathB[t] * START_CAPITAL;
                    }
                }

                // calcola medie
                const eqNoGrossAvg = eqNoGrossSum.map(v => v / sims);
                const eqNoNetAvg = eqNoNetSum.map(v => v / sims);
                const eqReGrossAvg = eqReGrossSum.map(v => v / sims);
                const eqReNetAvg = eqReNetSum.map(v => v / sims);
                const assetAAvg = assetASum.map(v => v / sims);
                const assetBAvg = assetBSum.map(v => v / sims);

                const avgNoGross = mean(finalNoGross);
                const avgNoNet = mean(finalNoNet);
                const avgReGross = mean(finalReGross);
                const avgReNet = mean(finalReNet);
                const avgTaxesNo = taxesNoSum / sims;
                const avgTaxesRe = taxesReSum / sims;
                const avgTaxesRePaid = taxesReSum / sims;
                const avgFinalCapitalGainRe = finalCapitalGainReSum / sims;
                const avgTaxesReTot = avgTaxesRePaid + avgFinalCapitalGainRe;



                // etichette anni
                const labels = Array.from({ length: years + 1 }, (_, i) => i);

                // distruggi vecchio grafico
                if (chartMC instanceof Chart) chartMC.destroy();

                // crea grafico lineare Monte Carlo medio
                chartMC = new Chart(document.getElementById("chartMonteCarlo"), {
                    type: 'line',
                    data: {
                        labels,
                        datasets: [
                            { label: "Asset A (medio)", data: assetAAvg, borderColor: 'rgba(75,192,192,1)', borderWidth: 1, borderDash: [5, 5], fill: false },
                            { label: "Asset B (medio)", data: assetBAvg, borderColor: 'rgba(255,159,64,1)', borderWidth: 1, borderDash: [5, 5], fill: false },
                            { label: "Buy & Hold lordo (medio)", data: eqNoGrossAvg, borderColor: 'rgba(75,192,192,0.8)', borderWidth: 2, fill: false },
                            //{ label: "Buy & Hold netto (medio)", data: eqNoNetAvg, borderColor: 'rgba(75,192,192,0.4)', borderWidth: 2, fill: false },
                            { label: "Ribilanciato lordo (medio)", data: eqReGrossAvg, borderColor: 'rgba(255,159,64,0.8)', borderWidth: 2, fill: false },
                            //{ label: "Ribilanciato netto (medio)", data: eqReNetAvg, borderColor: 'rgba(255,159,64,0.4)', borderWidth: 2, fill: false },
                        ]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            legend: { position: 'top' },
                            title: { display: true, text: 'üìä Andamento medio Monte Carlo' }
                        },
                        scales: {
                            y: { beginAtZero: false }
                        }
                    }
                });

                // Aggiorna anche la tabella dei risultati
                document.getElementById("stats").innerHTML = `
        <div class="mt-4">            
            <h2 class="mb-3">üìä Risultati simulazione</h2>
            <p>
                <b>${sims.toLocaleString()}</b> simulazioni<br>
                Capitale iniziale: <b>100.000 ‚Ç¨</b>
            </p>
            <div style="display:flex; gap:20px; flex-wrap:wrap;">
                <!-- BUY & HOLD -->
                <div style="flex:1; min-width:260px; padding:15px; border:1px solid #ddd; border-radius:8px;">
                    <h4>üìà Buy & Hold</h4>
                    <hr>
                    <div><b>Valore finale lordo medio:</b><br>${mean(finalNoGross).toLocaleString()} ‚Ç¨</div>
                    <div><b>Tasse latenti medie:</b><br>${avgTaxesNo.toLocaleString()} ‚Ç¨</div>
                    <div><b>Valore finale netto medio:</b><br>${mean(finalNoNet).toLocaleString()} ‚Ç¨</div>
                    <div><b>Volatilit√† annua media:</b><br>${(mean(volNo) * 100).toFixed(2)} %</div>
                </div>

                <!-- RIBILANCIAMENTO -->
                <div style="flex:1; min-width:260px; padding:15px; border:1px solid #ddd; border-radius:8px;">
                    <h4>‚öñÔ∏è Ribilanciamento annuale</h4>
                    <hr>
                    <div><b>Valore finale lordo medio:</b><br>${mean(finalReGross).toLocaleString()} ‚Ç¨</div>
                    <div><b>Tasse pagate medie (ribilanciamenti):</b><br>${avgTaxesRePaid.toLocaleString()} ‚Ç¨</div>
                    <div><b>Tasse capital gain finale medie:</b><br>${avgFinalCapitalGainRe.toLocaleString()} ‚Ç¨</div>
                    <div><b>Tasse totali medie:</b><br>${avgTaxesReTot.toLocaleString()} ‚Ç¨</div>
                    <div><b>Valore finale netto medio:</b><br>${mean(finalReNet).toLocaleString()} ‚Ç¨</div>
                    <div><b>Volatilit√† annua media:</b><br>${(mean(volRe) * 100).toFixed(2)} %</div>
                </div>
            </div>
            <br>
            <div>
                <div style="flex:1; min-width:260px; padding:15px; border:1px solid #ddd; border-radius:8px;">
                    <h4>üßÆ Differenze (Ribilanciato - Hold)</h4>
                    <hr>
                    <div><b>Differenza lordi:</b><br>${(mean(finalReGross) - mean(finalNoGross)).toLocaleString()} ‚Ç¨</div>
                    <div><b>Differenza netti:</b><br>${(mean(finalReNet) - mean(finalNoNet)).toLocaleString()} ‚Ç¨</div>
                    <div><b>Differenza volatilit√†:</b><br>${(mean(volRe) * 100 - mean(volNo) * 100).toFixed(2)} %</div>
                </div>
            </div>
        </div>
    `;

                mostraRiepilogoStatistiche(simulazioni);

            }

            run();
        </script>
    </div>
    <!-- Disclaimer -->
    <div id="disclaimer-container"></div>
    <script>
        document.addEventListener('DOMContentLoaded', function () {
            fetch('html/disclaimer.html')
                .then(response => response.text())
                .then(data => {
                    document.getElementById('disclaimer-container').innerHTML = data;
                });
        });
    </script>
</body>

</html>