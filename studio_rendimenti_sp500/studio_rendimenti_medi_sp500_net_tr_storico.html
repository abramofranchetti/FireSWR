<!DOCTYPE html>
<html lang="it">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Studio rendimenti medi S&P NET TR 500 storico</title>
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
    <link href="../css/style.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.5.4/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script
        src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial@0.2.1/dist/chartjs-chart-financial.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.0.2"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body class="bg-light">
    <div class="container mt-5 p-4 bg-white rounded shadow-sm">
        <div class="text-center mb-4">
            <a href="/FireSWR" class="home-button">üè† Home</a>
        </div>
        <br>
        <h1 class="text-center">Studio rendimenti medi S&P 500 NET TR storico</h1>
        <h5 class="text-center">Studio dei rendimenti annualizzati e totali per diversi periodi di detenzione
            (metodologia Rolling) per l'indice S&P 500 Net TR costruito sui dati di Shiller.
        <a href="https://abramofranchetti.github.io/FireSWR/#rendimenti_storici">vai qui per altre tipologie di indice (net price, net tr, ecc)</a>
        </h5>

        <h3 class="mt-4">S&P 500 ‚Äì Net Total Return (Reinvestimento dei dividendi tassati)</h3>
        <canvas id="chartTR"></canvas>

        <div class="mt-4 p-3 bg-light border rounded">
            <p>
                Nel grafico sotto √® riportato il rendimento annualizzato, tipicamente chiamato CAGR in finanza (Compound
                Annual Growth Rate).
                Il rendimento √® nominale, lordo ed include i dividendi.
                Per un investitore italiano, bisogna togliere la tassazione sui dividendi, la tassazione sulla
                plusvalenza ed inserire il cambio lira/dollaro prima ed EUR/dollaro poi.
            </p>
            <p>
                Come potete vedere, il rendimento netto annualizzato medio √® del 9.5%, ma nel 95% delle simulazioni tale
                rendimento oscilla fra il 5.9% e il 13.2%.
                Non sembrerebbe una grossa oscillazione, poich√© si parla di poco pi√π di un fattore 2 tra il limite
                inferiore e il limite superiore della banda.
            </p>
            <p>
                Ma √® proprio qui che sta l'inganno.
                Il rendimento annualizzato, difatti, non √® altro che la radice n-esima del rendimento totale e questa
                operazione, su un investimento di 30 anni, schiaccia la variazione dei rendimenti.
                Se ci spostiamo sul grafico ancora sotto, dove vengono rappresentati i rendimenti totali, vediamo come
                in realt√† la variazione fra il limite inferiore e il limite superiore √® in realt√†
                di quasi un fattore 10.
            </p>
            <p>
                üìå Se da un lato √® corretto affermare che nel passato un qualunque investimento trentennale sull'indice
                S&P 500 ha offerto un rendimento nominale decisamente positivo, dall'altro <strong> non possiamo affatto
                    affermare che il rendimento dell'azionario converge con l'allungarsi del periodo.</strong>
            </p>
            <p>
                Entrare ed uscire nel momento giusto vs entrare ed uscire nel momento sbagliato, avrebbe prodotto una
                differenza di un fattore 10 (+400% contro +4000%).
            </p>
        </div>

        <h3 class="mt-5">Rendimento annualizzato per periodo di detenzione, in evidenza il 90% percentile</h3>
        <canvas id="chartAnn"></canvas>

        <h3 class="mt-5">Rendimento totale per periodo di detenzione, in evidenza il 90% percentile</h3>
        <canvas id="chartTotal"></canvas>

        <div class="mt-4 p-3 bg-light border rounded">
            <h4>Conclusioni</h4>
            <p>I grafici mostrano come cambiano i rendimenti in base al periodo di detenzione: Le candele mostrano le
                fluttuazini e evidenziano il 90% percentile dei risultati e la mediana. Inoltre in arancione viene
                mostrato l'andamento dell'ultimo portafoglio osservato (esempio quello degli ultimi 1, 2, ..., 30 anni).
            </p>
            <ul>
                <li><strong>Rendimenti annualizzati:</strong> tendono a crescere con l'aumentare degli anni, riducendo
                    il rischio di perdite importanti, ma la variabilit√† resta significativa.</li>
                <li><strong>Rendimenti totali:</strong> mostrano una variabilit√† ancora maggiore, sottolineando
                    l'importanza del <strong>timing</strong> di ingresso e uscita dal mercato.</li>
                <li><strong>Linea rossa (media):</strong> evidenzia che, nonostante le fluttuazioni, i rendimenti
                    tendono a stabilizzarsi su valori positivi con l'allungarsi del periodo di detenzione.</li>
                <li><strong>Volatilit√†:</strong> aumenta con la durata del portafoglio; anche a lungo termine, il
                    rischio non scompare e il <strong>timing di ingresso e uscita</strong> rimane critico.</li>
            </ul>
            <p><em>In sintesi: investire a lungo termine pu√≤ aumentare le probabilit√† di rendimento positivo, ma non
                    elimina completamente il rischio.</em></p>
        </div>
        <div class="mt-4 p-3 bg-light border rounded">
            <h4>Approfondimenti</h4>
            <p>Per approfondire la questione allego il paper del 2010 di Andrea Malagoli, Stocks for the Long Run:
                Historical Facts and Statistical Fallacies disponibile <a
                    href="./Stocks for the Long Run Historical Facts and Statistical Fallacies - Andrea Malagoli.pdf"
                    target="_blank">qui</a>.</p>
            <p>Inoltre consiglio la lettura del libro di Jeremy Siegel, Stocks for the Long Run, disponibile in italiano
                come <em>"Azioni per il lungo periodo"</em>.</p>
            <p>Infine, per chi fosse interessato ad un'analisi pi√π tecnica sugli investimenti a lungo termine, consiglio
                il paper di Robert Shiller, <a href="http://www.econ.yale.edu/~shiller/data/ie_data.xls"
                    target="_blank">Irrational Exuberance</a>, che include i dati storici utilizzati in questo studio.
            </p>
            <p>Altri modi di vedere gli stessi dati, da <a
                    href="https://www.lazyportfolioetf.com/allocation/us-stocks-rolling-returns/" target="_blank">Lazy
                    Portfolio ETF</a></p>
            <img src="./annual_return.png">
            <img src="./total_return.png">
        </div>
    </div>

    <!-- Disclaimer -->
    <div id="disclaimer-container"></div>
    <script>
        /* =======================
           PARSE S&P 500 CSV
           ======================= */
        function parseSP500CSV(text) {
            return text.replace('\uFEFF', '').trim().split('\n').map(line => {
                const parts = line.trim().split(/\s+/);
                if (parts.length < 3) return null;
                const [ym, priceRaw, divRaw] = parts;
                if (!ym.includes(',')) return null;
                const [year, month] = ym.split(',').map(Number);
                const price = Number(priceRaw.replace(',', '.'));
                const dividend = Number(divRaw.replace(',', '.'));
                if (isNaN(price) || isNaN(dividend)) return null;
                return { date: new Date(Date.UTC(year, month - 1, 1)), price, dividend };
            }).filter(Boolean);
        }

        /* =======================
        BUILD NET TOTAL RETURN INDEX
        ======================= */
        function buildNetTotalReturnIndex(data, taxRate = 0.30) {
            if (!data.length) return [];

            const result = [{
                date: data[0].date,
                price: data[0].price,
                tr: 100
            }];

            for (let i = 1; i < data.length; i++) {
                const prev = result[i - 1];
                const curr = data[i];

                const monthlyDividendGross = curr.dividend / 12;
                const monthlyDividendNet = monthlyDividendGross * (1 - taxRate);

                const tr =
                    prev.tr *
                    ((curr.price + monthlyDividendNet) / prev.price);

                result.push({
                    date: curr.date,
                    price: curr.price,
                    tr
                });
            }

            return result;
        }


        function mean(arr) {
            return arr.reduce((a, b) => a + b, 0) / arr.length;
        }

        function percentile(arr, p) {
            if (!arr.length) return null;
            const sorted = [...arr].sort((a, b) => a - b);
            const idx = (sorted.length - 1) * p;
            const lo = Math.floor(idx);
            const hi = Math.ceil(idx);
            if (lo === hi) return sorted[lo];
            return sorted[lo] * (hi - idx) + sorted[hi] * (idx - lo);
        }

        function computeHoldingStats(trSeries, maxYears = 41) {
            const results = [];

            for (let years = 1; years <= maxYears; years++) {
                const months = years * 12;
                const totalReturns = [];
                const annualizedReturns = [];

                for (let i = 0; i + months < trSeries.length; i++) {
                    const start = trSeries[i].tr;
                    const end = trSeries[i + months].tr;

                    const total = end / start - 1;
                    const annualized = Math.pow(end / start, 1 / years) - 1;

                    totalReturns.push(total);
                    annualizedReturns.push(annualized);
                }

                const lastStartIndex = trSeries.length - months - 1;
                const lastStart = trSeries[lastStartIndex].tr;
                const lastEnd = trSeries[lastStartIndex + months].tr;

                const lastTotal = lastEnd / lastStart - 1;
                const lastAnn = Math.pow(lastEnd / lastStart, 1 / years) - 1;


                results.push({
                    years,
                    total: {
                        min: Math.min(...totalReturns),
                        max: Math.max(...totalReturns),
                        p10: percentile(totalReturns, 0.10),
                        p90: percentile(totalReturns, 0.90),
                        mean: mean(totalReturns),
                        last: lastTotal

                    },
                    ann: {
                        min: Math.min(...annualizedReturns),
                        max: Math.max(...annualizedReturns),
                        p10: percentile(annualizedReturns, 0.10),
                        p90: percentile(annualizedReturns, 0.90),
                        mean: mean(annualizedReturns),
                        last: lastAnn
                    }
                });
            }
            return results;
        }

        function buildHoldingBoxPlot(ctx, stats, type, label) {
            return new Chart(ctx, {
                type: 'candlestick',
                data: {
                    labels: stats.map(s => s.years),
                    datasets: [{
                        label,
                        data: buildFakeCandles(stats, type),
                        backgroundColor: 'rgba(173,216,230,0.6)',
                        borderColor: '#000',
                        borderWidth: 1,
                        itemRadius: 0,
                        pointStyle: 'circle',
                        showLine: false
                    },
                    {
                        type: 'scatter',
                        label: 'Mediana',
                        data: stats.map(s => ({ x: s.years, y: s[type].mean * 100 })),
                        pointBackgroundColor: 'red',
                        pointRadius: 2,
                    },
                    {
                        type: 'scatter',
                        label: 'Ultimo portafoglio',
                        data: stats.map(s => ({ x: s.years, y: s[type].last * 100 })),
                        pointBackgroundColor: 'orange',
                        pointBorderColor: 'black',
                        pointRadius: 2,
                    }
                    ]
                },
                plugins: [{
                    id: 'drawMedian',
                    afterDatasetsDraw(chart) {
                        const ctx = chart.ctx;
                        chart.data.datasets.forEach((dataset, i) => {
                            dataset.data.forEach((d, j) => {
                                const meta = chart.getDatasetMeta(i).data[j];
                                const x = meta.x; // posizione orizzontale candela
                                const y = chart.scales.y.getPixelForValue(d.median);
                                const halfWidth = meta.width / 2; // met√† larghezza candela
                                ctx.strokeStyle = 'red';
                                ctx.lineWidth = 0.5;
                                ctx.beginPath();
                                ctx.moveTo(x - halfWidth / 2, y);
                                ctx.lineTo(x + halfWidth / 2, y);
                                ctx.stroke();
                            });
                            dataset.data.forEach((d, j) => {
                                const meta = chart.getDatasetMeta(i).data[j];
                                const x = meta.x; // posizione orizzontale candela
                                const y = chart.scales.y.getPixelForValue(d.last);
                                const halfWidth = meta.width / 2; // met√† larghezza candela
                                ctx.strokeStyle = 'darkorange';
                                ctx.lineWidth = 0.5;
                                ctx.beginPath();
                                ctx.moveTo(x - halfWidth / 2, y);
                                ctx.lineTo(x + halfWidth / 2, y);
                                ctx.stroke();
                            });
                        });
                    }
                },
                ],
                options: {
                    plugins: {
                        legend: { display: true },
                        annotation: zeroLineAnnotation()
                    },
                    scales: {
                        x: {
                            type: 'category',
                            ticks: {
                                autoSkip: false,
                                maxRotation: 0,
                                minRotation: 0,
                                callback: (value) => value
                            },
                            title: {
                                display: true,
                                text: 'Anni di detenzione'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: '%'
                            }
                        }
                    }
                }
            });
        }

        function buildFakeCandles(stats, type) {
            return stats.map(s => ({
                x: s.years,
                o: s[type].p10 * 100,   // open
                h: s[type].max * 100,   // high
                l: s[type].min * 100,   // low
                c: s[type].p90 * 100,    // close
                median: s[type].mean * 100,
                last: s[type].last * 100
            }));
        }




        function zeroLineAnnotation() {
            return {
                annotations: {
                    zeroLine: {
                        type: 'line',
                        yMin: 0,
                        yMax: 0,
                        borderColor: 'black',
                        borderWidth: 1,
                        borderDash: [6, 4], // tratteggiata stile Shiller                        
                    }
                }
            };
        }



        /* =======================
           MAIN
           ======================= */
        async function main() {
            const spText = await fetch('./sp500_shiller_price_dividends.csv').then(r => r.text());
            const spParsed = parseSP500CSV(spText);
            const spTR = buildNetTotalReturnIndex(spParsed);
            const holdingStats = computeHoldingStats(spTR, 41);
            buildHoldingBoxPlot(document.getElementById('chartAnn'), holdingStats, 'ann', 'Rendimento annualizzato');
            buildHoldingBoxPlot(document.getElementById('chartTotal'), holdingStats, 'total', 'Rendimento totale');



            // --- GRAFICO S&P 500 TR ---
            new Chart(document.getElementById('chartTR'), {
                type: 'line',
                data: {
                    datasets: [
                        { label: 'S&P 500 Net Total Return (USD)', data: spTR.map(d => ({ x: d.date, y: d.tr })), borderWidth: 1, pointRadius: 0, borderColor: 'green' }
                    ]
                },
                options: { scales: { x: { type: 'time' }, y: { title: { display: true, text: 'USD' } } } }
            });
        }

        document.addEventListener('DOMContentLoaded', main);
    </script>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            fetch('../html/disclaimer.html')
                .then(response => response.text())
                .then(data => {
                    document.getElementById('disclaimer-container').innerHTML = data;
                });
        });
    </script>
</body>

</html>